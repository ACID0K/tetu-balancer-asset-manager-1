{
  "address": "0xa28d16f5bc2f6132fdf9939a1aa324d88ed33a56",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IBVault",
          "name": "_vault",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "claimAssetManagerRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address payable",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "minAmountsOut",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IBVault.ExitPoolRequest",
          "name": "request",
          "type": "tuple"
        },
        {
          "internalType": "uint256[]",
          "name": "minCashBalances",
          "type": "uint256[]"
        }
      ],
      "name": "exitPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        }
      ],
      "name": "hasCalledPool",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "maxAmountsIn",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IBVault.JoinPoolRequest",
          "name": "request",
          "type": "tuple"
        }
      ],
      "name": "joinPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vault",
      "outputs": [
        {
          "internalType": "contract IBVault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xad997c1c6e902634e2212b546da3d1cfd4f9d341fe1060b04933b239b09b5454",
  "receipt": {
    "to": null,
    "from": "0xaaa01cb6c7570733ae3eded876a98c9bc373803b",
    "contractAddress": "0xa28d16f5bc2f6132fdf9939a1aa324d88ed33a56",
    "transactionIndex": "0x1",
    "gasUsed": "0xf3d8f",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000040000000040000000000000000000000000000100000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000120000000000000000010000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x275aaeba670a9f8afe00ce45d88bbdeb761954ab72add5356da9b42c87a74d21",
    "transactionHash": "0xa0acc9ede31d4497581d8a5699a18a1e78d787df0d17d28f857b9e15fe62d4b6",
    "logs": [
      {
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000aaa01cb6c7570733ae3eded876a98c9bc373803b",
          "0x0000000000000000000000009ead03f7136fc6b4bdb0780b00a1c14ae5a8b6d0"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000433b403ff0e66240000000000000000000000000000000000000000000000003355987580e4547b0000000000000000000000000000000000000000000064817c6e70dc36e61f9c0000000000000000000000000000000000000000000000002f21e47181d5ee5700000000000000000000000000000000000000000000648180a224e035f485c0",
        "blockNumber": "0x21d7b23",
        "transactionHash": "0xa0acc9ede31d4497581d8a5699a18a1e78d787df0d17d28f857b9e15fe62d4b6",
        "transactionIndex": "0x1",
        "blockHash": "0x275aaeba670a9f8afe00ce45d88bbdeb761954ab72add5356da9b42c87a74d21",
        "logIndex": "0x1",
        "removed": false
      }
    ],
    "blockNumber": "0x21d7b23",
    "cumulativeGasUsed": "0x103053",
    "status": "0x1"
  },
  "args": [
    "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
  ],
  "numDeployments": 1,
  "solcInputHash": "fe38d9136e7a4282eee5c8ab30475865",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IBVault\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"claimAssetManagerRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IBVault.ExitPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"minCashBalances\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"hasCalledPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IBVault.JoinPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IBVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"this contract behaves as proxy for joinPool and exitPool operations.      Is able to move invested funds to the Balancer's vault and handle big exitPool requests.      Need to be approved by Balancer's governance.\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"all events are produced either AssetManagers or Balancer's vault.\"},\"hasCalledPool(bytes32)\":{\"details\":\"returns true if relayer processing rebalce request for the given pool (pool Id)\"}},\"title\":\"Relayer\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claimAssetManagerRewards(bytes32)\":{\"notice\":\"used to claim rewards from asset managers. Reward collection logic and         reward distribution controlled by AM\"},\"exitPool(bytes32,address,(address[],uint256[],bytes,bool),uint256[])\":{\"notice\":\"standard Balancer's vault exitPool request with the extra param minCashBalances.         minCashBalances - amounts of tokens for withdraw (exitPool). Used to calculate if AM should return tokens                           to the Balancer's vault to handle this request.         Calls asset manager's rebalance logic.\"},\"joinPool(bytes32,address,(address[],uint256[],bytes,bool))\":{\"notice\":\"a standard Balancer's vault joinPool request. Calls asset manager's rebalance logic.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Relayer.sol\":\"Relayer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"contracts/Relayer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./third_party/balancer/IBVault.sol\\\";\\nimport \\\"./interfaces/IAssetManagerBase.sol\\\";\\nimport \\\"./interfaces/IRelayer.sol\\\";\\n\\n/// @title Relayer\\n/// @dev this contract behaves as proxy for joinPool and exitPool operations.\\n///      Is able to move invested funds to the Balancer's vault and handle big exitPool requests.\\n///      Need to be approved by Balancer's governance.\\ncontract Relayer is IRelayer {\\n  // ***************************************************\\n  //                CONSTANTS\\n  // ***************************************************\\n\\n  // We start at a non-zero value to make EIP2200 refunds lower, meaning there'll be a higher chance of them being\\n  // fully effective.\\n  bytes32 internal constant _EMPTY_CALLED_POOL =\\n    bytes32(0x0000000000000000000000000000000000000000000000000000000000000001);\\n\\n  // ***************************************************\\n  //                VARIABLES\\n  // ***************************************************\\n\\n  IBVault public immutable vault;\\n  bytes32 internal _calledPool;\\n\\n  // ***************************************************\\n  //                  EVENTS\\n  // ***************************************************\\n\\n  /// @dev all events are produced either AssetManagers or Balancer's vault.\\n\\n  // ***************************************************\\n  //                CONSTRUCTOR\\n  // ***************************************************\\n\\n  constructor(IBVault _vault) {\\n    vault = _vault;\\n    _calledPool = _EMPTY_CALLED_POOL;\\n  }\\n\\n  // ***************************************************\\n  //                    VIEWS\\n  // ***************************************************\\n\\n  /// @dev returns true if relayer processing rebalce request for the given pool (pool Id)\\n  function hasCalledPool(bytes32 poolId) external view override returns (bool) {\\n    return _calledPool == poolId;\\n  }\\n\\n  // ***************************************************\\n  //                    CLAIM\\n  // ***************************************************\\n\\n  /// @notice used to claim rewards from asset managers. Reward collection logic and\\n  ///         reward distribution controlled by AM\\n  function claimAssetManagerRewards(bytes32 poolId) external override {\\n    (IERC20[] memory tokens, , ) = vault.getPoolTokens(poolId);\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      (, , , address assetManager) = vault.getPoolTokenInfo(poolId, tokens[i]);\\n      if (assetManager != address(0)) {\\n        IAssetManagerBase(assetManager).claimRewards();\\n      }\\n    }\\n  }\\n\\n  // ***************************************************\\n  //                    JOIN/EXIT\\n  // ***************************************************\\n\\n  /// @notice a standard Balancer's vault joinPool request. Calls asset manager's rebalance logic.\\n  function joinPool(\\n    bytes32 poolId,\\n    address recipient,\\n    IBVault.JoinPoolRequest memory request\\n  ) external rebalance(poolId, request.assets, new uint256[](request.assets.length)) {\\n    vault.joinPool(poolId, msg.sender, recipient, request);\\n  }\\n\\n  /// @notice standard Balancer's vault exitPool request with the extra param minCashBalances.\\n  ///         minCashBalances - amounts of tokens for withdraw (exitPool). Used to calculate if AM should return tokens\\n  ///                           to the Balancer's vault to handle this request.\\n  ///         Calls asset manager's rebalance logic.\\n  function exitPool(\\n    bytes32 poolId,\\n    address payable recipient,\\n    IBVault.ExitPoolRequest memory request,\\n    uint256[] memory minCashBalances\\n  ) external rebalance(poolId, request.assets, minCashBalances) {\\n    vault.exitPool(poolId, msg.sender, recipient, request);\\n  }\\n\\n  // ***************************************************\\n  //                 REBALANCE\\n  // ***************************************************\\n\\n  /// @dev used by joinPool and exitPool to handle big exitPool and 'soft' rebalance assets (invest/devest) via AM.\\n  modifier rebalance(\\n    bytes32 poolId,\\n    IAsset[] memory assets,\\n    uint256[] memory minCashBalances\\n  ) {\\n    require(_calledPool == _EMPTY_CALLED_POOL, \\\"Rebalancing relayer reentered\\\");\\n    IERC20[] memory tokens = _translateToIERC20(assets);\\n    _ensureCashBalance(poolId, tokens, minCashBalances);\\n    _calledPool = poolId;\\n    _;\\n    _rebalance(poolId, tokens);\\n    _calledPool = _EMPTY_CALLED_POOL;\\n  }\\n\\n  /// @dev used to handle big withdraws by devesting required funds via AM and to update Balancer's vault with the\\n  ///      latest state of funds controlled by AM.\\n  function _ensureCashBalance(\\n    bytes32 poolId,\\n    IERC20[] memory tokens,\\n    uint256[] memory minCashBalances\\n  ) internal {\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      (uint256 cash, , , address assetManager) = vault.getPoolTokenInfo(poolId, tokens[i]);\\n\\n      if (assetManager != address(0)) {\\n        uint256 cashNeeded = minCashBalances[i];\\n        if (cash < cashNeeded) {\\n          // Withdraw the managed balance back to the pool to ensure that the cash covers the withdrawal\\n          // This will automatically update the vault with the most recent managed balance\\n          IAssetManagerBase(assetManager).capitalOut(poolId, cashNeeded - cash);\\n        } else {\\n          // We want to ensure that the pool knows about all asset manager returns\\n          // to avoid a new LP getting a share of returns earned before they joined.\\n          // We then update the vault with the current managed balance manually.\\n          IAssetManagerBase(assetManager).updateBalanceOfPool(poolId);\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @dev calls 'soft' rebalace for attached AM.\\n  function _rebalance(bytes32 poolId, IERC20[] memory tokens) internal {\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      (, , , address assetManager) = vault.getPoolTokenInfo(poolId, tokens[i]);\\n      if (assetManager != address(0)) {\\n        // Note that malicious Asset Managers could perform reentrant calls at this stage and e.g. try to exit\\n        // the Pool before Managers for other tokens have rebalanced. This is considered a non-issue as a) no\\n        // exploits should be enabled by allowing for this, and b) Pools trust their Asset Managers.\\n\\n        // Do a non-forced rebalance\\n        IAssetManagerBase(assetManager).rebalance(poolId, false);\\n      }\\n    }\\n  }\\n\\n  // ***************************************************\\n  //                 COMMON INTERNAL\\n  // ***************************************************\\n\\n  function _translateToIERC20(IAsset[] memory assets) internal pure returns (IERC20[] memory) {\\n    IERC20[] memory tokens = new IERC20[](assets.length);\\n    for (uint256 i = 0; i < assets.length; ++i) {\\n      tokens[i] = IERC20(address(assets[i]));\\n    }\\n    return tokens;\\n  }\\n}\\n\",\"keccak256\":\"0x226f7597e8620e609277016f1d86f2299c96ab075ba97a9a86b2dc78dbebb02e\",\"license\":\"MIT\"},\"contracts/interfaces/IAssetManagerBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../third_party/balancer/IAssetManager.sol\\\";\\n\\n\\ninterface IAssetManagerBase is IAssetManager {\\n\\n  struct InvestmentConfig {\\n    uint64 targetPercentage;\\n    uint64 upperCriticalPercentage;\\n    uint64 lowerCriticalPercentage;\\n  }\\n\\n  function initialize(bytes32 poolId) external;\\n\\n  function getInvestmentConfig(bytes32 pId) external view returns (InvestmentConfig memory);\\n\\n  function claimRewards() external;\\n}\\n\",\"keccak256\":\"0x98210a96cf0026dc965f2d9f2f0f9ae3e016b1fcecf78c4c4b06aaba01a00e9a\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0xfebb5c1b4a6fb589f445d76be35dc2a12195bf93f426a64bbb628d63b05457d5\",\"license\":\"MIT\"},\"contracts/interfaces/IRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../third_party/balancer/IBasePoolRelayer8.sol\\\";\\n\\ninterface IRelayer is IBasePoolRelayer {\\n\\n  function claimAssetManagerRewards(bytes32 poolId) external;\\n\\n}\\n\",\"keccak256\":\"0x28baa93594ad58bf3fce3f77ed59c0d66e3f171d066b818bd7e1741d1a56d640\",\"license\":\"MIT\"},\"contracts/third_party/balancer/IAssetManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../../interfaces/IERC20.sol\\\";\\n\\n\\ninterface IAssetManager {\\n    /**\\n     * @notice Emitted when asset manager is rebalanced\\n     */\\n    event Rebalance(bytes32 poolId);\\n\\n    /**\\n     * @notice Sets the config\\n     */\\n    function setConfig(bytes32 poolId, bytes calldata config) external;\\n\\n    /**\\n     * Note: No function to read the asset manager config is included in IAssetManager\\n     * as the signature is expected to vary between asset manager implementations\\n     */\\n\\n    /**\\n     * @notice Returns the asset manager's token\\n     */\\n    function getToken() external view returns (IERC20);\\n\\n    /**\\n     * @return the current assets under management of this asset manager\\n     */\\n    function getAUM(bytes32 poolId) external view returns (uint256);\\n\\n    /**\\n     * @return poolCash - The up-to-date cash balance of the pool\\n     * @return poolManaged - The up-to-date managed balance of the pool\\n     */\\n    function getPoolBalances(bytes32 poolId) external view returns (uint256 poolCash, uint256 poolManaged);\\n\\n    /**\\n     * @return The difference in tokens between the target investment\\n     * and the currently invested amount (i.e. the amount that can be invested)\\n     */\\n    function maxInvestableBalance(bytes32 poolId) external view returns (int256);\\n\\n    /**\\n     * @notice Updates the Vault on the value of the pool's investment returns\\n     */\\n    function updateBalanceOfPool(bytes32 poolId) external;\\n\\n    /**\\n     * @notice Determines whether the pool should rebalance given the provided balances\\n     */\\n    function shouldRebalance(uint256 cash, uint256 managed) external view returns (bool);\\n\\n    /**\\n     * @notice Rebalances funds between the pool and the asset manager to maintain target investment percentage.\\n     * @param poolId - the poolId of the pool to be rebalanced\\n     * @param force - a boolean representing whether a rebalance should be forced even when the pool is near balance\\n     */\\n    function rebalance(bytes32 poolId, bool force) external;\\n\\n    /**\\n     * @notice allows an authorized rebalancer to remove capital to facilitate large withdrawals\\n     * @param poolId - the poolId of the pool to withdraw funds back to\\n     * @param amount - the amount of tokens to withdraw back to the pool\\n     */\\n    function capitalOut(bytes32 poolId, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0xc75b9436e16f8fcfb4cd28279ff39d08a0dd4d211ebb69954095665adced5a30\",\"license\":\"GPL-3.0-or-later\"},\"contracts/third_party/balancer/IBVault.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.4;\\n\\nimport \\\"../../interfaces/IERC20.sol\\\";\\n\\n\\ninterface IAsset {\\n}\\n\\ninterface IBVault {\\n  // Relayers\\n  //\\n  // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\\n  // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\\n  // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\\n  // this power, two things must occur:\\n  //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\\n  //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\\n  //    functions.\\n  //  - Each user must approve the relayer to act on their behalf.\\n  // This double protection means users cannot be tricked into approving malicious relayers (because they will not\\n  // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\\n  // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\\n\\n  /**\\n   * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\\n     */\\n  function hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n\\n  /**\\n   * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\\n     *\\n     * Emits a `RelayerApprovalChanged` event.\\n     */\\n  function setRelayerApproval(\\n    address sender,\\n    address relayer,\\n    bool approved\\n  ) external;\\n\\n\\n\\n  // Internal Balance\\n  //\\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n  //\\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n  // operations of different kinds, with different senders and recipients, at once.\\n\\n  /**\\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\\n\\n  /**\\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\\n\\n  /**\\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n  struct UserBalanceOp {\\n    UserBalanceOpKind kind;\\n    IAsset asset;\\n    uint256 amount;\\n    address sender;\\n    address payable recipient;\\n  }\\n\\n  // There are four possible operations in `manageUserBalance`:\\n  //\\n  // - DEPOSIT_INTERNAL\\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n  //\\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n  // relevant for relayers).\\n  //\\n  // Emits an `InternalBalanceChanged` event.\\n  //\\n  //\\n  // - WITHDRAW_INTERNAL\\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n  //\\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n  // it to the recipient as ETH.\\n  //\\n  // Emits an `InternalBalanceChanged` event.\\n  //\\n  //\\n  // - TRANSFER_INTERNAL\\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n  //\\n  // Reverts if the ETH sentinel value is passed.\\n  //\\n  // Emits an `InternalBalanceChanged` event.\\n  //\\n  //\\n  // - TRANSFER_EXTERNAL\\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n  // relayers, as it lets them reuse a user's Vault allowance.\\n  //\\n  // Reverts if the ETH sentinel value is passed.\\n  //\\n  // Emits an `ExternalBalanceTransfer` event.\\n\\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\\n\\n  /**\\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n     * interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n     * address.\\n     */\\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n  /**\\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n  // Pools\\n  //\\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n  // functionality:\\n  //\\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n  // which increase with the number of registered tokens.\\n  //\\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n  // independent of the number of registered tokens.\\n  //\\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\\n\\n  /**\\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n     * changed.\\n     *\\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n     *\\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n     * multiple Pools may share the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n  /**\\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\\n\\n  /**\\n   * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n  /**\\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n     * ascending order.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n     * Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n     * different Asset Manager.\\n     *\\n     * Emits a `TokensRegistered` event.\\n     */\\n  function registerTokens(\\n    bytes32 poolId,\\n    IERC20[] calldata tokens,\\n    address[] calldata assetManagers\\n  ) external;\\n\\n  /**\\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n  /**\\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\\n\\n  /**\\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n  /**\\n   * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n     * `managed` or `total` balance to be greater than 2^112 - 1.\\n     *\\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n     * change for this purpose, and will update `lastChangeBlock`.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n  external\\n  view\\n  returns (\\n    uint256 cash,\\n    uint256 managed,\\n    uint256 lastChangeBlock,\\n    address assetManager\\n  );\\n\\n  /**\\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n     * the tokens' `balances` changed.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n     * instead.\\n     */\\n  function getPoolTokens(bytes32 poolId)\\n  external\\n  view\\n  returns (\\n    IERC20[] memory tokens,\\n    uint256[] memory balances,\\n    uint256 lastChangeBlock\\n  );\\n\\n  /**\\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n  function joinPool(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    JoinPoolRequest calldata request\\n  ) external payable;\\n\\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\\n\\n  struct JoinPoolRequest {\\n    IAsset[] assets;\\n    uint256[] maxAmountsIn;\\n    bytes userData;\\n    bool fromInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n  function exitPool(\\n    bytes32 poolId,\\n    address sender,\\n    address payable recipient,\\n    ExitPoolRequest calldata request\\n  ) external;\\n\\n  struct ExitPoolRequest {\\n    IAsset[] assets;\\n    uint256[] minAmountsOut;\\n    bytes userData;\\n    bool toInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n     */\\n  event PoolBalanceChanged(\\n    bytes32 indexed poolId,\\n    address indexed liquidityProvider,\\n    IERC20[] tokens,\\n    int256[] deltas,\\n    uint256[] protocolFeeAmounts\\n  );\\n\\n  enum PoolBalanceChangeKind {JOIN, EXIT}\\n\\n  // Swaps\\n  //\\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n  //\\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n  // individual swaps.\\n  //\\n  // There are two swap kinds:\\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n  //\\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n  // the final intended token.\\n  //\\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n  // much less gas than they would otherwise.\\n  //\\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n  // updating the Pool's internal accounting).\\n  //\\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\\n  //\\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n  //\\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n  //\\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\\n\\n  /**\\n   * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n  function swap(\\n    SingleSwap calldata singleSwap,\\n    FundManagement calldata funds,\\n    uint256 limit,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  /**\\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n  struct SingleSwap {\\n    bytes32 poolId;\\n    SwapKind kind;\\n    IAsset assetIn;\\n    IAsset assetOut;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  /**\\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n  function batchSwap(\\n    SwapKind kind,\\n    BatchSwapStep[] calldata swaps,\\n    IAsset[] calldata assets,\\n    FundManagement calldata funds,\\n    int256[] calldata limits,\\n    uint256 deadline\\n  ) external payable returns (int256[] memory);\\n\\n  /**\\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n  struct BatchSwapStep {\\n    bytes32 poolId;\\n    uint256 assetInIndex;\\n    uint256 assetOutIndex;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  /**\\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n  event Swap(\\n    bytes32 indexed poolId,\\n    IERC20 indexed tokenIn,\\n    IERC20 indexed tokenOut,\\n    uint256 amountIn,\\n    uint256 amountOut\\n  );\\n\\n  /**\\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n  struct FundManagement {\\n    address sender;\\n    bool fromInternalBalance;\\n    address payable recipient;\\n    bool toInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n  function queryBatchSwap(\\n    SwapKind kind,\\n    BatchSwapStep[] calldata swaps,\\n    IAsset[] calldata assets,\\n    FundManagement calldata funds\\n  ) external returns (int256[] memory assetDeltas);\\n\\n  // BasePool.sol\\n\\n  /**\\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee percentage and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n  function queryExit(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    uint256[] memory balances,\\n    uint256 lastChangeBlock,\\n    uint256 protocolSwapFeePercentage,\\n    bytes memory userData\\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\\n\\n  enum PoolBalanceOpKind {WITHDRAW, DEPOSIT, UPDATE}\\n\\n  struct PoolBalanceOp {\\n    PoolBalanceOpKind kind;\\n    bytes32 poolId;\\n    IERC20 token;\\n    uint256 amount;\\n  }\\n\\n  function managePoolBalance(PoolBalanceOp[] memory ops) external;\\n\\n  function getActionId(bytes4 selector) external view returns (bytes32);\\n\\n\\n}\\n\",\"keccak256\":\"0x488db7ea62b10584f90d4fb61d5eda638f9b851980939a69655b61a56c0e5ba6\",\"license\":\"ISC\"},\"contracts/third_party/balancer/IBasePoolRelayer8.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.4;\\n\\ninterface IBasePoolRelayer {\\n\\n  function hasCalledPool(bytes32 poolId) external view returns (bool);\\n\\n}\\n\",\"keccak256\":\"0x5d5323b24a5961802ea97143bd652e49845c9d4fc03c639343e5cc60c10e0144\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161117238038061117283398101604081905261002f91610049565b60601b6001600160601b0319166080526001600055610077565b60006020828403121561005a578081fd5b81516001600160a01b0381168114610070578182fd5b9392505050565b60805160601c6110b46100be6000396000818160c601528181610192015281816102f4015281816103920152818161042c0152818161066d015261088a01526110b46000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80635c93c3b01461005c578063b2cca2e314610071578063d5a9d03e14610084578063dd0a7e2614610097578063fbfa77cf146100c1575b600080fd5b61006f61006a366004610d23565b610100565b005b61006f61007f366004610d9f565b610218565b61006f610092366004610d0b565b610379565b6100ac6100a5366004610d0b565b6000541490565b60405190151581526020015b60405180910390f35b6100e87f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100b8565b8151600054859190839060011461015e5760405162461bcd60e51b815260206004820152601d60248201527f526562616c616e63696e672072656c61796572207265656e746572656400000060448201526064015b60405180910390fd5b600061016983610582565b905061017684828461065c565b6000849055604051638bdb391360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638bdb3913906101cd908b9033908c908c90600401610f51565b600060405180830381600087803b1580156101e757600080fd5b505af11580156101fb573d6000803e3d6000fd5b50505050610209848261087a565b50506001600055505050505050565b805180518491906001600160401b0381111561024457634e487b7160e01b600052604160045260246000fd5b60405190808252806020026020018201604052801561026d578160200160208202803683370190505b506000546001146102c05760405162461bcd60e51b815260206004820152601d60248201527f526562616c616e63696e672072656c61796572207265656e74657265640000006044820152606401610155565b60006102cb83610582565b90506102d884828461065c565b600084905560405163172b958560e31b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063b95cac289061032f908a9033908b908b90600401610f51565b600060405180830381600087803b15801561034957600080fd5b505af115801561035d573d6000803e3d6000fd5b5050505061036b848261087a565b505060016000555050505050565b604051631f29a8cd60e31b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f94d46689060240160006040518083038186803b1580156103dc57600080fd5b505afa1580156103f0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526104189190810190610c3d565b5050905060005b815181101561057d5760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b05f8e488585858151811061047a57634e487b7160e01b600052603260045260246000fd5b60200260200101516040518363ffffffff1660e01b81526004016104b19291909182526001600160a01b0316602082015260400190565b60806040518083038186803b1580156104c957600080fd5b505afa1580156104dd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105019190610df5565b935050506001600160a01b03821615905061056a57806001600160a01b031663372500ab6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561055157600080fd5b505af1158015610565573d6000803e3d6000fd5b505050505b50806105758161101f565b91505061041f565b505050565b6060600082516001600160401b038111156105ad57634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156105d6578160200160208202803683370190505b50905060005b83518110156106555783818151811061060557634e487b7160e01b600052603260045260246000fd5b602002602001015182828151811061062d57634e487b7160e01b600052603260045260246000fd5b6001600160a01b039092166020928302919091019091015261064e8161101f565b90506105dc565b5092915050565b60005b8251811015610874576000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b05f8e48878786815181106106bb57634e487b7160e01b600052603260045260246000fd5b60200260200101516040518363ffffffff1660e01b81526004016106f29291909182526001600160a01b0316602082015260400190565b60806040518083038186803b15801561070a57600080fd5b505afa15801561071e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107429190610df5565b92945091925050506001600160a01b0381161561085f57600084848151811061077b57634e487b7160e01b600052603260045260246000fd5b6020026020010151905080831015610802576001600160a01b038216632b13a509886107a78685611008565b6040516001600160e01b031960e085901b16815260048101929092526024820152604401600060405180830381600087803b1580156107e557600080fd5b505af11580156107f9573d6000803e3d6000fd5b5050505061085d565b604051630b5ff6b960e01b8152600481018890526001600160a01b03831690630b5ff6b990602401600060405180830381600087803b15801561084457600080fd5b505af1158015610858573d6000803e3d6000fd5b505050505b505b5050808061086c9061101f565b91505061065f565b50505050565b60005b815181101561057d5760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b05f8e48858585815181106108d857634e487b7160e01b600052603260045260246000fd5b60200260200101516040518363ffffffff1660e01b815260040161090f9291909182526001600160a01b0316602082015260400190565b60806040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190610df5565b935050506001600160a01b0382161590506109d657604051632649b6c560e11b815260048101859052600060248201526001600160a01b03821690634c936d8a90604401600060405180830381600087803b1580156109bd57600080fd5b505af11580156109d1573d6000803e3d6000fd5b505050505b50806109e18161101f565b91505061087d565b600082601f8301126109f9578081fd5b81356020610a0e610a0983610fe5565b610fb5565b80838252828201915082860187848660051b8901011115610a2d578586fd5b855b85811015610a54578135610a4281611066565b84529284019290840190600101610a2f565b5090979650505050505050565b600082601f830112610a71578081fd5b81356020610a81610a0983610fe5565b80838252828201915082860187848660051b8901011115610aa0578586fd5b855b85811015610a5457813584529284019290840190600101610aa2565b600082601f830112610ace578081fd5b81516020610ade610a0983610fe5565b80838252828201915082860187848660051b8901011115610afd578586fd5b855b85811015610a5457815184529284019290840190600101610aff565b80358015158114610b2b57600080fd5b919050565b600082601f830112610b40578081fd5b81356001600160401b03811115610b5957610b59611050565b610b6c601f8201601f1916602001610fb5565b818152846020838601011115610b80578283fd5b816020850160208301379081016020019190915292915050565b600060808284031215610bab578081fd5b610bb3610f8d565b905081356001600160401b0380821115610bcc57600080fd5b610bd8858386016109e9565b83526020840135915080821115610bee57600080fd5b610bfa85838601610a61565b60208401526040840135915080821115610c1357600080fd5b50610c2084828501610b30565b604083015250610c3260608301610b1b565b606082015292915050565b600080600060608486031215610c51578283fd5b83516001600160401b0380821115610c67578485fd5b818601915086601f830112610c7a578485fd5b81516020610c8a610a0983610fe5565b8083825282820191508286018b848660051b8901011115610ca957898afd5b8996505b84871015610cd4578051610cc081611066565b835260019690960195918301918301610cad565b5091890151919750909350505080821115610ced578384fd5b50610cfa86828701610abe565b925050604084015190509250925092565b600060208284031215610d1c578081fd5b5035919050565b60008060008060808587031215610d38578182fd5b843593506020850135610d4a81611066565b925060408501356001600160401b0380821115610d65578384fd5b610d7188838901610b9a565b93506060870135915080821115610d86578283fd5b50610d9387828801610a61565b91505092959194509250565b600080600060608486031215610db3578081fd5b833592506020840135610dc581611066565b915060408401356001600160401b03811115610ddf578182fd5b610deb86828701610b9a565b9150509250925092565b60008060008060808587031215610e0a578182fd5b8451935060208501519250604085015191506060850151610e2a81611066565b939692955090935050565b6000815180845260208085019450808401835b83811015610e6457815187529582019590820190600101610e48565b509495945050505050565b60008151808452815b81811015610e9457602081850181015186830182015201610e78565b81811115610ea55782602083870101525b50601f01601f19169290920160200192915050565b8051608080845281519084018190526000916020919082019060a0860190845b81811015610eff5783516001600160a01b031683529284019291840191600101610eda565b505082850151915085810383870152610f188183610e35565b9250505060408301518482036040860152610f338282610e6f565b9150506060830151610f49606086018215159052565b509392505050565b8481526001600160a01b03848116602083015283166040820152608060608201819052600090610f8390830184610eba565b9695505050505050565b604051608081016001600160401b0381118282101715610faf57610faf611050565b60405290565b604051601f8201601f191681016001600160401b0381118282101715610fdd57610fdd611050565b604052919050565b60006001600160401b03821115610ffe57610ffe611050565b5060051b60200190565b60008282101561101a5761101a61103a565b500390565b60006000198214156110335761103361103a565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461107b57600080fd5b5056fea264697066735822122084b57a6b101a67e62273b8cc480a11a52b06d8d52f257cb695468f7b029acbf264736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c80635c93c3b01461005c578063b2cca2e314610071578063d5a9d03e14610084578063dd0a7e2614610097578063fbfa77cf146100c1575b600080fd5b61006f61006a366004610d23565b610100565b005b61006f61007f366004610d9f565b610218565b61006f610092366004610d0b565b610379565b6100ac6100a5366004610d0b565b6000541490565b60405190151581526020015b60405180910390f35b6100e87f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020016100b8565b8151600054859190839060011461015e5760405162461bcd60e51b815260206004820152601d60248201527f526562616c616e63696e672072656c61796572207265656e746572656400000060448201526064015b60405180910390fd5b600061016983610582565b905061017684828461065c565b6000849055604051638bdb391360e01b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638bdb3913906101cd908b9033908c908c90600401610f51565b600060405180830381600087803b1580156101e757600080fd5b505af11580156101fb573d6000803e3d6000fd5b50505050610209848261087a565b50506001600055505050505050565b805180518491906001600160401b0381111561024457634e487b7160e01b600052604160045260246000fd5b60405190808252806020026020018201604052801561026d578160200160208202803683370190505b506000546001146102c05760405162461bcd60e51b815260206004820152601d60248201527f526562616c616e63696e672072656c61796572207265656e74657265640000006044820152606401610155565b60006102cb83610582565b90506102d884828461065c565b600084905560405163172b958560e31b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063b95cac289061032f908a9033908b908b90600401610f51565b600060405180830381600087803b15801561034957600080fd5b505af115801561035d573d6000803e3d6000fd5b5050505061036b848261087a565b505060016000555050505050565b604051631f29a8cd60e31b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f94d46689060240160006040518083038186803b1580156103dc57600080fd5b505afa1580156103f0573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526104189190810190610c3d565b5050905060005b815181101561057d5760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b05f8e488585858151811061047a57634e487b7160e01b600052603260045260246000fd5b60200260200101516040518363ffffffff1660e01b81526004016104b19291909182526001600160a01b0316602082015260400190565b60806040518083038186803b1580156104c957600080fd5b505afa1580156104dd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105019190610df5565b935050506001600160a01b03821615905061056a57806001600160a01b031663372500ab6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561055157600080fd5b505af1158015610565573d6000803e3d6000fd5b505050505b50806105758161101f565b91505061041f565b505050565b6060600082516001600160401b038111156105ad57634e487b7160e01b600052604160045260246000fd5b6040519080825280602002602001820160405280156105d6578160200160208202803683370190505b50905060005b83518110156106555783818151811061060557634e487b7160e01b600052603260045260246000fd5b602002602001015182828151811061062d57634e487b7160e01b600052603260045260246000fd5b6001600160a01b039092166020928302919091019091015261064e8161101f565b90506105dc565b5092915050565b60005b8251811015610874576000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b05f8e48878786815181106106bb57634e487b7160e01b600052603260045260246000fd5b60200260200101516040518363ffffffff1660e01b81526004016106f29291909182526001600160a01b0316602082015260400190565b60806040518083038186803b15801561070a57600080fd5b505afa15801561071e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107429190610df5565b92945091925050506001600160a01b0381161561085f57600084848151811061077b57634e487b7160e01b600052603260045260246000fd5b6020026020010151905080831015610802576001600160a01b038216632b13a509886107a78685611008565b6040516001600160e01b031960e085901b16815260048101929092526024820152604401600060405180830381600087803b1580156107e557600080fd5b505af11580156107f9573d6000803e3d6000fd5b5050505061085d565b604051630b5ff6b960e01b8152600481018890526001600160a01b03831690630b5ff6b990602401600060405180830381600087803b15801561084457600080fd5b505af1158015610858573d6000803e3d6000fd5b505050505b505b5050808061086c9061101f565b91505061065f565b50505050565b60005b815181101561057d5760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b05f8e48858585815181106108d857634e487b7160e01b600052603260045260246000fd5b60200260200101516040518363ffffffff1660e01b815260040161090f9291909182526001600160a01b0316602082015260400190565b60806040518083038186803b15801561092757600080fd5b505afa15801561093b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095f9190610df5565b935050506001600160a01b0382161590506109d657604051632649b6c560e11b815260048101859052600060248201526001600160a01b03821690634c936d8a90604401600060405180830381600087803b1580156109bd57600080fd5b505af11580156109d1573d6000803e3d6000fd5b505050505b50806109e18161101f565b91505061087d565b600082601f8301126109f9578081fd5b81356020610a0e610a0983610fe5565b610fb5565b80838252828201915082860187848660051b8901011115610a2d578586fd5b855b85811015610a54578135610a4281611066565b84529284019290840190600101610a2f565b5090979650505050505050565b600082601f830112610a71578081fd5b81356020610a81610a0983610fe5565b80838252828201915082860187848660051b8901011115610aa0578586fd5b855b85811015610a5457813584529284019290840190600101610aa2565b600082601f830112610ace578081fd5b81516020610ade610a0983610fe5565b80838252828201915082860187848660051b8901011115610afd578586fd5b855b85811015610a5457815184529284019290840190600101610aff565b80358015158114610b2b57600080fd5b919050565b600082601f830112610b40578081fd5b81356001600160401b03811115610b5957610b59611050565b610b6c601f8201601f1916602001610fb5565b818152846020838601011115610b80578283fd5b816020850160208301379081016020019190915292915050565b600060808284031215610bab578081fd5b610bb3610f8d565b905081356001600160401b0380821115610bcc57600080fd5b610bd8858386016109e9565b83526020840135915080821115610bee57600080fd5b610bfa85838601610a61565b60208401526040840135915080821115610c1357600080fd5b50610c2084828501610b30565b604083015250610c3260608301610b1b565b606082015292915050565b600080600060608486031215610c51578283fd5b83516001600160401b0380821115610c67578485fd5b818601915086601f830112610c7a578485fd5b81516020610c8a610a0983610fe5565b8083825282820191508286018b848660051b8901011115610ca957898afd5b8996505b84871015610cd4578051610cc081611066565b835260019690960195918301918301610cad565b5091890151919750909350505080821115610ced578384fd5b50610cfa86828701610abe565b925050604084015190509250925092565b600060208284031215610d1c578081fd5b5035919050565b60008060008060808587031215610d38578182fd5b843593506020850135610d4a81611066565b925060408501356001600160401b0380821115610d65578384fd5b610d7188838901610b9a565b93506060870135915080821115610d86578283fd5b50610d9387828801610a61565b91505092959194509250565b600080600060608486031215610db3578081fd5b833592506020840135610dc581611066565b915060408401356001600160401b03811115610ddf578182fd5b610deb86828701610b9a565b9150509250925092565b60008060008060808587031215610e0a578182fd5b8451935060208501519250604085015191506060850151610e2a81611066565b939692955090935050565b6000815180845260208085019450808401835b83811015610e6457815187529582019590820190600101610e48565b509495945050505050565b60008151808452815b81811015610e9457602081850181015186830182015201610e78565b81811115610ea55782602083870101525b50601f01601f19169290920160200192915050565b8051608080845281519084018190526000916020919082019060a0860190845b81811015610eff5783516001600160a01b031683529284019291840191600101610eda565b505082850151915085810383870152610f188183610e35565b9250505060408301518482036040860152610f338282610e6f565b9150506060830151610f49606086018215159052565b509392505050565b8481526001600160a01b03848116602083015283166040820152608060608201819052600090610f8390830184610eba565b9695505050505050565b604051608081016001600160401b0381118282101715610faf57610faf611050565b60405290565b604051601f8201601f191681016001600160401b0381118282101715610fdd57610fdd611050565b604052919050565b60006001600160401b03821115610ffe57610ffe611050565b5060051b60200190565b60008282101561101a5761101a61103a565b500390565b60006000198214156110335761103361103a565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461107b57600080fd5b5056fea264697066735822122084b57a6b101a67e62273b8cc480a11a52b06d8d52f257cb695468f7b029acbf264736f6c63430008040033",
  "devdoc": {
    "details": "this contract behaves as proxy for joinPool and exitPool operations.      Is able to move invested funds to the Balancer's vault and handle big exitPool requests.      Need to be approved by Balancer's governance.",
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "all events are produced either AssetManagers or Balancer's vault."
      },
      "hasCalledPool(bytes32)": {
        "details": "returns true if relayer processing rebalce request for the given pool (pool Id)"
      }
    },
    "title": "Relayer",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "claimAssetManagerRewards(bytes32)": {
        "notice": "used to claim rewards from asset managers. Reward collection logic and         reward distribution controlled by AM"
      },
      "exitPool(bytes32,address,(address[],uint256[],bytes,bool),uint256[])": {
        "notice": "standard Balancer's vault exitPool request with the extra param minCashBalances.         minCashBalances - amounts of tokens for withdraw (exitPool). Used to calculate if AM should return tokens                           to the Balancer's vault to handle this request.         Calls asset manager's rebalance logic."
      },
      "joinPool(bytes32,address,(address[],uint256[],bytes,bool))": {
        "notice": "a standard Balancer's vault joinPool request. Calls asset manager's rebalance logic."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1580,
        "contract": "contracts/Relayer.sol:Relayer",
        "label": "_calledPool",
        "offset": 0,
        "slot": "0",
        "type": "t_bytes32"
      }
    ],
    "types": {
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      }
    }
  }
}