{
  "language": "Solidity",
  "sources": {
    "contracts/AssetManagerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./openzeppelin/SafeERC20.sol\";\nimport \"./third_party/balancer/IBVault.sol\";\nimport \"./third_party/balancer/IRelayedBasePool8.sol\";\nimport \"./interfaces/IAssetManagerBase.sol\";\n\n/// @title TetuRewardsAssetManager\n/// @dev TetuRewardsAssetManager is owned by a single pool such that any\n///      rewards received by the Asset Manager may be distributed to LPs\n///      Note: any behaviour to claim these rewards must be implemented in a derived contract\nabstract contract AssetManagerBase is IAssetManagerBase {\n  using SafeERC20 for IERC20;\n\n  // ***************************************************\n  //                CONSTANTS\n  // ***************************************************\n\n  uint256 private constant _CONFIG_PRECISION = 1e18;\n\n  // ***************************************************\n  //                VARIABLES\n  // ***************************************************\n\n  IBVault public immutable balancerVault;\n  IERC20 public immutable underlying;\n\n  /// @dev RewardsAssetManager manages a single Pool, to which it allocates all rewards that it receives.\n  bytes32 public poolId;\n  InvestmentConfig internal _config;\n\n  // ***************************************************\n  //                EVENTS\n  // ***************************************************\n\n  event InvestmentConfigSet(uint64 targetPercentage, uint64 lowerCriticalPercentage, uint64 upperCriticalPercentage);\n  event AssetManagerInitialized(bytes32 poolId);\n  event CapitalIn(bytes32 poolId);\n  event CapitalOut(bytes32 poolId);\n  event PoolBalanceUpdated(bytes32 poolId, uint256 newAUM);\n\n  // ***************************************************\n  //               Virtual functions\n  // ***************************************************\n\n  /**\n   * @dev Invests capital inside the asset manager\n   * @param amount - the amount of tokens being deposited\n   * @return the number of tokens that were deposited\n   */\n  function _invest(uint256 amount) internal virtual returns (uint256);\n\n  /**\n   * @dev Divests capital back to the asset manager\n   * @param amount - the amount of tokens being withdrawn\n   * @return the number of tokens to return to the vault\n   */\n  function _divest(uint256 amount) internal virtual returns (uint256);\n\n  // ***************************************************\n  //                CONSTRUCTOR/INITIALIZATION\n  // ***************************************************\n  constructor(IBVault balancerVault_, IERC20 underlying_) {\n    require(address(underlying_) != address(0), \"zero token\");\n    require(address(balancerVault_) != address(0), \"zero balancer vault\");\n\n    underlying_.safeApprove(address(balancerVault_), type(uint256).max);\n\n    balancerVault = balancerVault_;\n    underlying = underlying_;\n  }\n\n  /// @dev Should be called in same transaction as deployment through a factory contract\n  /// @param pId - the id of the pool\n  /// @notice We need to provide AM during pool creation but AM should know the PoolID.\n  ///   To resolve this cyclic reference we need to have a separate method to store poolId\n  function initialize(bytes32 pId) external override {\n    require(poolId == bytes32(0), \"Already initialised\");\n    require(pId != bytes32(0), \"Pool id cannot be empty\");\n    poolId = pId;\n    emit AssetManagerInitialized(poolId);\n  }\n\n  // ***************************************************\n  //                RESTRICTIONS/MODIFIERS\n  // ***************************************************\n\n  /// @dev Reverts if called by any account other than the pool.\n  modifier onlyPoolContract() {\n    require(msg.sender == getPoolAddress(), \"Only callable by pool\");\n    _;\n  }\n\n  /// @dev Reverts if called by any account other than the Rebalancer (relayer).\n  modifier onlyPoolRebalancer() {\n    require(\n      msg.sender == address(IRelayedBasePool(getPoolAddress()).getRelayer()),\n      \"Only callable by authorized rebalancer\"\n    );\n    _;\n  }\n\n  /// @dev Reverts if called with incorrect poolId.\n  modifier withCorrectPool(bytes32 pId) {\n    require(pId == poolId, \"AssetManager called with incorrect poolId\");\n    _;\n  }\n\n  // ***************************************************\n  //                      VIEWS\n  // ***************************************************\n\n  /// @notice return underlying token which managed by AssetManager\n  function getToken() external view override returns (IERC20) {\n    return underlying;\n  }\n\n  /// @notice return attached pool address for this Asset Manager\n  function getPoolAddress() public view returns (address addr) {\n    uint256 shifted = uint256(poolId) / 2**(8 * 12);\n    return address(uint160(shifted));\n  }\n\n  /// @dev returns amount of tokens which will be invested or devested during rebalace action.\n  /// Could be negative number in case of devest.\n  /// @notice return amount of underlying token which can be invested by AM according to configuration.\n  /// After the rebalance expected to be 0\n  /// e.g target is 80% and current investment is 60% thus 20% of pool TVL can be invested.\n  function maxInvestableBalance(bytes32 pId) external view override withCorrectPool(pId) returns (int256) {\n    uint256 aum = _getAUM();\n    (uint256 poolCash, , , ) = balancerVault.getPoolTokenInfo(poolId, underlying);\n    // Calculate the managed portion of funds locally as the Vault is unaware of returns\n    return int256(((poolCash + aum) * _config.targetPercentage) / _CONFIG_PRECISION) - int256(aum);\n  }\n\n  /// @param pId - the poolId\n  /// @notice return investment config\n  function getInvestmentConfig(bytes32 pId)\n    external\n    view\n    override\n    withCorrectPool(pId)\n    returns (InvestmentConfig memory)\n  {\n    return _config;\n  }\n\n  /// @param pId - the poolId\n  /// @notice shows amount of tokens in Balancer Vault and controlled by the AM.\n  function getPoolBalances(bytes32 pId)\n    external\n    view\n    override\n    withCorrectPool(pId)\n    returns (uint256 poolCash, uint256 poolManaged)\n  {\n    (poolCash, poolManaged) = _getPoolBalances(_getAUM());\n  }\n\n  function _getPoolBalances(uint256 aum) public view returns (uint256 poolCash, uint256 poolManaged) {\n    (poolCash, , , ) = balancerVault.getPoolTokenInfo(poolId, underlying);\n    // Calculate the managed portion of funds locally as the Vault is unaware of returns\n    poolManaged = aum;\n  }\n\n  /// @notice Determines whether the pool should rebalance given the provided balances\n  function shouldRebalance(uint256 cash, uint256 managed) public view override returns (bool) {\n    uint256 investedPercentage = (cash * _CONFIG_PRECISION) / (cash + managed);\n    InvestmentConfig memory config = _config;\n    return investedPercentage > config.upperCriticalPercentage || investedPercentage < config.lowerCriticalPercentage;\n  }\n\n  /// @param pId - the poolId\n  /// @notice shows amount of tokens under management by this AM (currently invested)\n  function getAUM(bytes32 pId) external view override withCorrectPool(pId) returns (uint256) {\n    return _getAUM();\n  }\n\n  function _getAUM() internal view virtual returns (uint256);\n\n  // ***************************************************\n  //                 POOL ACTIONS\n  // ***************************************************\n\n  /// @notice pool should be configured with following params:\n  ///   targetPercentage - amount of tokens in percents with _CONFIG_PRECISION which will be invested by the AM\n  ///    upperCriticalPercentage - when rebalace called without force flag affects shouldRebalance function.\n  ///       If invested amount is greater than this amount in percents, shouldRebalance returns true.\n  //    lowerCriticalPercentage - when rebalace called without force flag affects shouldRebalance function.\n  ///       If invested amount is lower than this amount in percents, shouldRebalance returns true.\n  function setConfig(bytes32 pId, bytes memory rawConfig) external override withCorrectPool(pId) onlyPoolContract {\n    InvestmentConfig memory config = abi.decode(rawConfig, (InvestmentConfig));\n\n    require(\n      config.upperCriticalPercentage <= _CONFIG_PRECISION,\n      \"Upper critical level must be less than or equal to 100%\"\n    );\n    require(\n      config.targetPercentage <= config.upperCriticalPercentage,\n      \"Target must be less than or equal to upper critical level\"\n    );\n    require(\n      config.lowerCriticalPercentage <= config.targetPercentage,\n      \"Lower critical level must be less than or equal to target\"\n    );\n\n    _config = config;\n    emit InvestmentConfigSet(config.targetPercentage, config.lowerCriticalPercentage, config.upperCriticalPercentage);\n  }\n\n  // ***************************************************\n  //              POOL REBALANCER ACTIONS\n  // ***************************************************\n\n  /// @notice allows an authorized rebalancer to remove capital to facilitate large withdrawals\n  /// @param pId - the poolId of the pool to withdraw funds back to\n  /// @param amount - the amount of tokens to withdraw back to the pool\n  function capitalOut(bytes32 pId, uint256 amount) external override withCorrectPool(pId) onlyPoolRebalancer {\n    _capitalOut(amount);\n  }\n\n  // ***************************************************\n  //              DEPOSIT / WITHDRAW / CLAIM\n  // ***************************************************\n\n  /// @dev Transfers capital into the asset manager, and then invests it\n  /// @param amount - the amount of tokens being deposited\n  function _capitalIn(uint256 amount) private {\n    IBVault.PoolBalanceOp[] memory ops = new IBVault.PoolBalanceOp[](2);\n    // Update the vault with new managed balance accounting for returns\n    ops[0] = IBVault.PoolBalanceOp(IBVault.PoolBalanceOpKind.UPDATE, poolId, underlying, _getAUM());\n    // Pull funds from the vault\n    ops[1] = IBVault.PoolBalanceOp(IBVault.PoolBalanceOpKind.WITHDRAW, poolId, underlying, amount);\n    balancerVault.managePoolBalance(ops);\n\n    _invest(amount);\n  }\n\n  /**\n   * @notice Divests capital back to the asset manager and then sends it to the vault\n   * @param amount - the amount of tokens to withdraw to the vault\n   */\n  function _capitalOut(uint256 amount) private {\n    uint256 aum = _getAUM();\n    uint256 tokensOut = _divest(amount);\n    IBVault.PoolBalanceOp[] memory ops = new IBVault.PoolBalanceOp[](2);\n    // Update the vault with new managed balance accounting for returns\n    ops[0] = IBVault.PoolBalanceOp(IBVault.PoolBalanceOpKind.UPDATE, poolId, underlying, aum);\n    // Send funds back to the vault\n    ops[1] = IBVault.PoolBalanceOp(IBVault.PoolBalanceOpKind.DEPOSIT, poolId, underlying, tokensOut);\n\n    balancerVault.managePoolBalance(ops);\n  }\n\n  /// @dev Claim all rewards and send to rewardCollector\n  function claimRewards() external override {\n    _claim();\n  }\n\n  function _claim() internal virtual;\n\n  // ***************************************************\n  //                 UPDATE/REBALANCE\n  //               without restrictions\n  // ***************************************************\n\n  /// @dev Is used to update Balancer's vault with amount controlled by AM.\n  /// E.g. if amount of tokens increased due to compounded investments.\n  function updateBalanceOfPool(bytes32 pId) external override withCorrectPool(pId) {\n    uint256 managedBalance = _getAUM();\n\n    IBVault.PoolBalanceOp memory transfer = IBVault.PoolBalanceOp(\n      IBVault.PoolBalanceOpKind.UPDATE,\n      pId,\n      underlying,\n      managedBalance\n    );\n    IBVault.PoolBalanceOp[] memory ops = new IBVault.PoolBalanceOp[](1);\n    ops[0] = (transfer);\n\n    balancerVault.managePoolBalance(ops);\n    emit PoolBalanceUpdated(poolId, managedBalance);\n  }\n\n  /// @param force - if true rebalaces pool immediately to target value from AM config,\n  ///        otherwise checks shouldRebalance first.\n  /// @notice Rebalances funds between pool and asset manager to maintain target investment percentage.\n  function rebalance(bytes32 pId, bool force) external override withCorrectPool(pId) {\n    if (force) {\n      _rebalance();\n    } else {\n      (uint256 poolCash, uint256 poolManaged) = _getPoolBalances(_getAUM());\n      if (shouldRebalance(poolCash, poolManaged)) {\n        _rebalance();\n      }\n    }\n  }\n\n  function _rebalance() internal {\n    (uint256 poolCash, uint256 poolManaged) = _getPoolBalances(_getAUM());\n    InvestmentConfig memory config = _config;\n\n    uint256 targetInvestment = ((poolCash + poolManaged) * config.targetPercentage) / _CONFIG_PRECISION;\n    if (targetInvestment > poolManaged) {\n      // Pool is under-invested so add more funds\n      uint256 rebalanceAmount = targetInvestment - poolManaged;\n      _capitalIn(rebalanceAmount);\n    } else {\n      // Pool is over-invested so remove some funds\n      uint256 rebalanceAmount = poolManaged - targetInvestment;\n      if (rebalanceAmount != 0) {\n        _capitalOut(rebalanceAmount);\n      }\n    }\n\n    emit Rebalance(poolId);\n  }\n}\n"
    },
    "contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.6/contracts/token/ERC20/utils/SafeERC20.sol\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint value\n  ) internal {\n    uint newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint value\n  ) internal {\n  unchecked {\n    uint oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "contracts/third_party/balancer/IBVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.4;\n\nimport \"../../interfaces/IERC20.sol\";\n\n\ninterface IAsset {\n}\n\ninterface IBVault {\n  // Relayers\n  //\n  // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\n  // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\n  // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\n  // this power, two things must occur:\n  //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\n  //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\n  //    functions.\n  //  - Each user must approve the relayer to act on their behalf.\n  // This double protection means users cannot be tricked into approving malicious relayers (because they will not\n  // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\n  // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\n\n  /**\n   * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\n     */\n  function hasApprovedRelayer(address user, address relayer) external view returns (bool);\n\n  /**\n   * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\n     *\n     * Emits a `RelayerApprovalChanged` event.\n     */\n  function setRelayerApproval(\n    address sender,\n    address relayer,\n    bool approved\n  ) external;\n\n\n\n  // Internal Balance\n  //\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n  //\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n  // operations of different kinds, with different senders and recipients, at once.\n\n  /**\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\n\n  /**\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\n\n  /**\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n  struct UserBalanceOp {\n    UserBalanceOpKind kind;\n    IAsset asset;\n    uint256 amount;\n    address sender;\n    address payable recipient;\n  }\n\n  // There are four possible operations in `manageUserBalance`:\n  //\n  // - DEPOSIT_INTERNAL\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n  // relevant for relayers).\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - WITHDRAW_INTERNAL\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n  // it to the recipient as ETH.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_INTERNAL\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_EXTERNAL\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n  // relayers, as it lets them reuse a user's Vault allowance.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `ExternalBalanceTransfer` event.\n\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\n\n  /**\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n  /**\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n  // Pools\n  //\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n  // functionality:\n  //\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n  // which increase with the number of registered tokens.\n  //\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n  // independent of the number of registered tokens.\n  //\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\n\n  /**\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n  /**\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n  /**\n   * @dev Returns a Pool's contract address and specialization setting.\n     */\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n  /**\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n  function registerTokens(\n    bytes32 poolId,\n    IERC20[] calldata tokens,\n    address[] calldata assetManagers\n  ) external;\n\n  /**\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n  /**\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\n\n  /**\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n  /**\n   * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n  external\n  view\n  returns (\n    uint256 cash,\n    uint256 managed,\n    uint256 lastChangeBlock,\n    address assetManager\n  );\n\n  /**\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n  function getPoolTokens(bytes32 poolId)\n  external\n  view\n  returns (\n    IERC20[] memory tokens,\n    uint256[] memory balances,\n    uint256 lastChangeBlock\n  );\n\n  /**\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n  function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    JoinPoolRequest calldata request\n  ) external payable;\n\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\n\n  struct JoinPoolRequest {\n    IAsset[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n  }\n\n  /**\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    ExitPoolRequest calldata request\n  ) external;\n\n  struct ExitPoolRequest {\n    IAsset[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n  event PoolBalanceChanged(\n    bytes32 indexed poolId,\n    address indexed liquidityProvider,\n    IERC20[] tokens,\n    int256[] deltas,\n    uint256[] protocolFeeAmounts\n  );\n\n  enum PoolBalanceChangeKind {JOIN, EXIT}\n\n  // Swaps\n  //\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n  //\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n  // individual swaps.\n  //\n  // There are two swap kinds:\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n  //\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n  // the final intended token.\n  //\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n  // much less gas than they would otherwise.\n  //\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n  // updating the Pool's internal accounting).\n  //\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\n  //\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\n  //\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n  //\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n  /**\n   * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n  function swap(\n    SingleSwap calldata singleSwap,\n    FundManagement calldata funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n  function batchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds,\n    int256[] calldata limits,\n    uint256 deadline\n  ) external payable returns (int256[] memory);\n\n  /**\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n  event Swap(\n    bytes32 indexed poolId,\n    IERC20 indexed tokenIn,\n    IERC20 indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n  );\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n  function queryBatchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds\n  ) external returns (int256[] memory assetDeltas);\n\n  // BasePool.sol\n\n  /**\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  enum PoolBalanceOpKind {WITHDRAW, DEPOSIT, UPDATE}\n\n  struct PoolBalanceOp {\n    PoolBalanceOpKind kind;\n    bytes32 poolId;\n    IERC20 token;\n    uint256 amount;\n  }\n\n  function managePoolBalance(PoolBalanceOp[] memory ops) external;\n\n  function getActionId(bytes4 selector) external view returns (bytes32);\n\n\n}\n"
    },
    "contracts/third_party/balancer/IRelayedBasePool8.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.4;\n\nimport \"./IBasePoolRelayer8.sol\";\n\ninterface IRelayedBasePool {\n  function getRelayer() external view returns (IBasePoolRelayer);\n}\n"
    },
    "contracts/interfaces/IAssetManagerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../third_party/balancer/IAssetManager.sol\";\n\n\ninterface IAssetManagerBase is IAssetManager {\n\n  struct InvestmentConfig {\n    uint64 targetPercentage;\n    uint64 upperCriticalPercentage;\n    uint64 lowerCriticalPercentage;\n  }\n\n  function initialize(bytes32 poolId) external;\n\n  function getInvestmentConfig(bytes32 pId) external view returns (InvestmentConfig memory);\n\n  function claimRewards() external;\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/utils/AddressUpgradeable.sol\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "contracts/third_party/balancer/IBasePoolRelayer8.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.4;\n\ninterface IBasePoolRelayer {\n\n  function hasCalledPool(bytes32 poolId) external view returns (bool);\n\n}\n"
    },
    "contracts/third_party/balancer/IAssetManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.4;\n\nimport \"../../interfaces/IERC20.sol\";\n\n\ninterface IAssetManager {\n    /**\n     * @notice Emitted when asset manager is rebalanced\n     */\n    event Rebalance(bytes32 poolId);\n\n    /**\n     * @notice Sets the config\n     */\n    function setConfig(bytes32 poolId, bytes calldata config) external;\n\n    /**\n     * Note: No function to read the asset manager config is included in IAssetManager\n     * as the signature is expected to vary between asset manager implementations\n     */\n\n    /**\n     * @notice Returns the asset manager's token\n     */\n    function getToken() external view returns (IERC20);\n\n    /**\n     * @return the current assets under management of this asset manager\n     */\n    function getAUM(bytes32 poolId) external view returns (uint256);\n\n    /**\n     * @return poolCash - The up-to-date cash balance of the pool\n     * @return poolManaged - The up-to-date managed balance of the pool\n     */\n    function getPoolBalances(bytes32 poolId) external view returns (uint256 poolCash, uint256 poolManaged);\n\n    /**\n     * @return The difference in tokens between the target investment\n     * and the currently invested amount (i.e. the amount that can be invested)\n     */\n    function maxInvestableBalance(bytes32 poolId) external view returns (int256);\n\n    /**\n     * @notice Updates the Vault on the value of the pool's investment returns\n     */\n    function updateBalanceOfPool(bytes32 poolId) external;\n\n    /**\n     * @notice Determines whether the pool should rebalance given the provided balances\n     */\n    function shouldRebalance(uint256 cash, uint256 managed) external view returns (bool);\n\n    /**\n     * @notice Rebalances funds between the pool and the asset manager to maintain target investment percentage.\n     * @param poolId - the poolId of the pool to be rebalanced\n     * @param force - a boolean representing whether a rebalance should be forced even when the pool is near balance\n     */\n    function rebalance(bytes32 poolId, bool force) external;\n\n    /**\n     * @notice allows an authorized rebalancer to remove capital to facilitate large withdrawals\n     * @param poolId - the poolId of the pool to withdraw funds back to\n     * @param amount - the amount of tokens to withdraw back to the pool\n     */\n    function capitalOut(bytes32 poolId, uint256 amount) external;\n}\n"
    },
    "contracts/TetuVaultAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./openzeppelin/SafeERC20.sol\";\nimport \"./openzeppelin/Math.sol\";\nimport \"./third_party/balancer/IBVault.sol\";\nimport \"./interfaces/ISmartVault.sol\";\nimport \"./interfaces/IGauge.sol\";\nimport \"./AssetManagerBase.sol\";\n\n/// @title TetuVaultAssetManager\n/// @dev TetuVaultAssetManager can invest funds to the TETU vault.\n/// Rewards will be claimed and distributed by governance\n\ncontract TetuVaultAssetManager is AssetManagerBase {\n  using SafeERC20 for IERC20;\n\n  // ***************************************************\n  //                VARIABLES\n  // ***************************************************\n\n  address public immutable tetuVault;\n\n  // ***************************************************\n  //                  EVENTS\n  // ***************************************************\n\n  event Invested(uint256 amount);\n  event Devested(uint256 amount);\n\n  // ***************************************************\n  //                CONSTRUCTOR\n  // ***************************************************\n\n  constructor(\n    IBVault balancerVault_,\n    address tetuVault_,\n    address underlying_\n  ) AssetManagerBase(balancerVault_, IERC20(underlying_)) {\n    require(tetuVault_ != address(0), \"zero tetu vault\");\n    tetuVault = tetuVault_;\n    IERC20(underlying_).safeIncreaseAllowance(tetuVault_, type(uint256).max);\n  }\n\n  // ***************************************************\n  //                VIEWS\n  // ***************************************************\n\n  /**\n   * @dev Checks balance of managed assets\n   */\n  function _getAUM() internal view override returns (uint256) {\n    return ISmartVault(tetuVault).underlyingBalanceWithInvestmentForHolder(address(this));\n  }\n\n  // ***************************************************\n  //                MAIN LOGIC\n  // ***************************************************\n\n  /**\n   * @dev Deposits capital into Tetu Vault\n   * @param amount - the amount of tokens being deposited\n   * @return the amount deposited\n   */\n  function _invest(uint256 amount) internal override returns (uint256) {\n    uint256 sharesBefore = IERC20(tetuVault).balanceOf(address(this));\n    // invest to Tetu Vault\n    ISmartVault(tetuVault).deposit(amount);\n    uint256 sharesAfter = IERC20(tetuVault).balanceOf(address(this));\n\n    require(sharesAfter > sharesBefore, \"AM should receive shares after the deposit\");\n    emit Invested(amount);\n    return amount;\n  }\n\n  /**\n   * @dev Withdraws capital out of Tetu Vault\n   * @param amountUnderlying - the amount to withdraw\n   * @return the number of tokens to return to the balancerVault\n   */\n  function _divest(uint256 amountUnderlying) internal override returns (uint256) {\n    uint256 existingBalance = underlying.balanceOf(address(this));\n\n    uint256 numberOfShares = (amountUnderlying * ISmartVault(tetuVault).underlyingUnit()) /\n      ISmartVault(tetuVault).getPricePerFullShare();\n    numberOfShares = Math.min(numberOfShares, IERC20(address(tetuVault)).balanceOf(address(this)));\n    ISmartVault(tetuVault).withdraw(numberOfShares);\n\n    uint256 newBalance = underlying.balanceOf(address(this));\n    uint256 divested = newBalance - existingBalance;\n    require(divested > 0, \"AM should receive requested tokens after the withdraw\");\n    emit Devested(divested);\n    return divested;\n  }\n\n  /// @dev Rewards will be claimed by the TETU governance\n  function _claim() internal pure override {}\n}\n"
    },
    "contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n   * zero.\n   */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n   *\n   * This differs from standard division with `/` in that it rounds up instead\n   * of rounding down.\n   */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a / b + (a % b == 0 ? 0 : 1);\n  }\n}\n"
    },
    "contracts/interfaces/ISmartVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface ISmartVault {\n\n  function deposit(uint256 amount) external;\n\n  function underlyingBalanceInVault() external view returns (uint256);\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n  function underlyingUnit() external view returns (uint256);\n\n  function getPricePerFullShare() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IGauge {\n\n  function getAllRewards(\n    address stakingToken,\n    address account\n  ) external;\n\n  function rewardTokensLength(address stakingToken) external view returns (uint);\n\n  function rewardTokens(address stakingToken, uint tokenIndex) external view returns (address);\n}\n"
    },
    "contracts/test/MockGague.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../interfaces/IGauge.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\n\ncontract MockGague is IGauge {\n  using SafeERC20 for IERC20;\n\n  address[] public _rewardTokens;\n  uint[] public dummyRewardAmounts;\n  address public stackingToken;\n\n  mapping(address => uint) _rewardTokensLength;\n\n  constructor(address[] memory rewardTokens_, uint[] memory _dummyRewardAmounts, address _stackingToken){\n    require(_stackingToken != address(0), \"zero stackingToken\");\n    _rewardTokens = rewardTokens_;\n    dummyRewardAmounts = _dummyRewardAmounts;\n    stackingToken = _stackingToken;\n    _rewardTokensLength[stackingToken] = rewardTokens_.length;\n\n  }\n\n  function getAllRewards(\n    address,\n    address account\n  ) external override {\n    for (uint i = 0; i < _rewardTokens.length; i++) {\n      IERC20(_rewardTokens[i]).safeTransfer(account, dummyRewardAmounts[i]);\n    }\n\n  }\n\n  function rewardTokensLength(address _stakingToken) external view override returns (uint){\n    return _rewardTokensLength[_stakingToken];\n  }\n\n  function rewardTokens(address, uint tokenIndex) external view override returns (address){\n    return _rewardTokens[tokenIndex];\n  }\n\n}\n"
    },
    "contracts/test/MockTetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract MockTetuVaultV2 is IERC4626, ERC20 {\n  using SafeERC20 for IERC20;\n\n  IERC20 public asset;\n  bool isReturnTokens;\n  bool isReturnShares;\n  uint constant feeDen = 100;\n  uint feeNom = 0;\n\n  constructor(\n    address _asset,\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    bool _isReturnShares,\n    bool _isReturnTokens\n  )ERC20(_name, _symbol, _decimals)  {\n    isReturnShares = _isReturnShares;\n    isReturnTokens = _isReturnTokens;\n    asset = IERC20(_asset);\n  }\n\n  function setFeeNom(uint256 _feeNom) external {\n    feeNom = _feeNom;\n  }\n\n  function deposit(uint assets, address receiver) external override returns (uint shares){\n    uint fee = assets * feeNom / feeDen;\n\n    asset.safeTransferFrom(msg.sender, address(this), assets - fee);\n    // fee simulation\n    asset.safeTransferFrom(msg.sender, address(0), fee);\n\n    if (isReturnShares) {\n      _mint(receiver, assets);\n    }\n    return assets;\n  }\n\n  function mint(uint shares, address receiver) external override returns (uint assets){\n    asset.safeTransferFrom(msg.sender, address(this), assets);\n    if (isReturnShares) {\n      _mint(receiver, assets);\n    }\n    return shares;\n  }\n\n  function withdraw(\n    uint assets,\n    address receiver,\n    address owner\n  ) external override returns (uint shares){\n    _burn(owner, assets);\n    if (isReturnTokens) {\n      asset.safeTransfer(receiver, assets);\n    }\n    return assets;\n  }\n\n  function redeem(\n    uint shares,\n    address receiver,\n    address owner\n  ) external override returns (uint assets){\n    _burn(owner, shares);\n    if (isReturnTokens) {\n      asset.safeTransfer(receiver, shares);\n    }\n    return shares;\n  }\n\n  function totalAssets() public view override returns (uint){\n    return asset.balanceOf(address(this));\n  }\n\n  function convertToShares(uint assets) external pure override returns (uint){\n    return assets;\n  }\n\n  function convertToAssets(uint shares) external view override returns (uint){\n   return totalSupply == 0 ? shares : (shares * totalAssets()) / totalSupply;\n  }\n\n  function previewDeposit(uint assets) external pure override returns (uint){\n    return assets;\n  }\n\n  function previewMint(uint shares) external pure override returns (uint){\n    return shares;\n  }\n\n  function previewWithdraw(uint assets) external pure override returns (uint){\n    return assets;\n  }\n\n  function previewRedeem(uint shares) external pure override returns (uint){\n    return shares;\n  }\n\n  function maxDeposit(address) external pure override returns (uint){\n    return 1e18;\n  }\n\n  function maxMint(address) external pure override returns (uint){\n    return 1e18;\n  }\n\n  function maxWithdraw(address owner) external view override returns (uint){\n    return balanceOf[owner];\n  }\n\n  function maxRedeem(address owner) external view override returns (uint){\n    return balanceOf[owner];\n  }\n\n\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IERC4626 {\n\n  event Deposit(address indexed caller, address indexed owner, uint assets, uint shares);\n\n  event Withdraw(\n    address indexed caller,\n    address indexed receiver,\n    address indexed owner,\n    uint assets,\n    uint shares\n  );\n\n\n  function deposit(uint assets, address receiver) external returns (uint shares);\n\n  function mint(uint shares, address receiver) external returns (uint assets);\n\n  function withdraw(\n    uint assets,\n    address receiver,\n    address owner\n  ) external returns (uint shares);\n\n  function redeem(\n    uint shares,\n    address receiver,\n    address owner\n  ) external returns (uint assets);\n\n  function totalAssets() external view returns (uint);\n\n  function convertToShares(uint assets) external view returns (uint);\n\n  function convertToAssets(uint shares) external view returns (uint);\n\n  function previewDeposit(uint assets) external view returns (uint);\n\n  function previewMint(uint shares) external view returns (uint);\n\n  function previewWithdraw(uint assets) external view returns (uint);\n\n  function previewRedeem(uint shares) external view returns (uint);\n\n  function maxDeposit(address) external view returns (uint);\n\n  function maxMint(address) external view returns (uint);\n\n  function maxWithdraw(address owner) external view returns (uint);\n\n  function maxRedeem(address owner) external view returns (uint);\n\n}\n"
    },
    "contracts/ERC4626AssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./openzeppelin/SafeERC20.sol\";\nimport \"./openzeppelin/Math.sol\";\nimport \"./third_party/balancer/IBVault.sol\";\nimport \"./interfaces/IERC4626.sol\";\nimport \"./interfaces/IGauge.sol\";\nimport \"./AssetManagerBase.sol\";\n\n/// @title ERC4626AssetManager\n/// @dev ERC4626AssetManager can invest funds to ERC4626 vault and collect the rewards from gauge.\n///      Currently configured to work with TetuVaultV2.\ncontract ERC4626AssetManager is AssetManagerBase {\n  using SafeERC20 for IERC20;\n\n  // ***************************************************\n  //                VARIABLES\n  // ***************************************************\n\n  address public immutable erc4626Vault;\n\n  /// @notice rewards from gauge are transferred to this address\n  address public immutable rewardCollector;\n  IGauge public immutable gauge;\n\n  // ***************************************************\n  //                  EVENTS\n  // ***************************************************\n\n  event Invested(uint256 amount);\n  event Devested(uint256 amount);\n  event RewardClaimed(address token, uint256 amount);\n\n  // ***************************************************\n  //                CONSTRUCTOR\n  // ***************************************************\n\n  constructor(\n    IBVault balancerVault_,\n    address erc4626Vault_,\n    address underlying_,\n    address rewardCollector_,\n    address gauge_\n  ) AssetManagerBase(balancerVault_, IERC20(underlying_)) {\n    require(erc4626Vault_ != address(0), \"zero ERC4626 vault\");\n    require(rewardCollector_ != address(0), \"zero rewardCollector\");\n    erc4626Vault = erc4626Vault_;\n    rewardCollector = rewardCollector_;\n    gauge = IGauge(gauge_);\n\n    IERC20(underlying_).safeIncreaseAllowance(erc4626Vault_, type(uint256).max);\n  }\n\n  // ***************************************************\n  //                VIEWS\n  // ***************************************************\n\n  /**\n   * @dev Checks balance of managed assets\n   */\n  function _getAUM() internal view override returns (uint256) {\n    return IERC4626(erc4626Vault).convertToAssets(IERC20(erc4626Vault).balanceOf(address(this)));\n  }\n\n  // ***************************************************\n  //                MAIN LOGIC\n  // ***************************************************\n\n  /**\n   * @dev Deposits capital into ERC4626 Vault\n   * @param amount - the amount of tokens being deposited\n   * @return the amount deposited\n   */\n  function _invest(uint256 amount) internal override returns (uint256) {\n    uint256 sharesBefore = IERC20(erc4626Vault).balanceOf(address(this));\n\n    // invest to ERC4626 Vault\n    IERC4626(erc4626Vault).deposit(amount, address(this));\n    uint256 sharesAfter = IERC20(erc4626Vault).balanceOf(address(this));\n\n    require(sharesAfter > sharesBefore, \"AM should receive shares after the deposit\");\n    emit Invested(amount);\n    return amount;\n  }\n\n  /**\n   * @dev Withdraws capital out of ERC4626 Vault\n   * @param amountUnderlying - the amount to withdraw\n   * @return the number of tokens to return to the balancerVault\n   */\n  function _divest(uint256 amountUnderlying) internal override returns (uint256) {\n    amountUnderlying = Math.min(amountUnderlying, IERC4626(erc4626Vault).maxWithdraw(address(this)));\n    uint256 existingBalance = underlying.balanceOf(address(this));\n    IERC4626(erc4626Vault).withdraw(amountUnderlying, address(this), address(this));\n    uint256 newBalance = underlying.balanceOf(address(this));\n    uint256 divested = newBalance - existingBalance;\n    require(divested > 0, \"AM should receive requested tokens after the withdraw\");\n    emit Devested(divested);\n    return divested;\n  }\n\n  /// @dev Claim all rewards from given gague and send to rewardCollector\n  function _claim() internal override {\n    if (address(gauge) != address(0) && rewardCollector != address(0)) {\n      gauge.getAllRewards(address(erc4626Vault), address(this));\n      for (uint256 i = 0; i < gauge.rewardTokensLength(address(erc4626Vault)); i++) {\n        IERC20 rt = IERC20(gauge.rewardTokens(address(erc4626Vault), i));\n        uint256 bal = IERC20(rt).balanceOf(address(this));\n        if (bal > 0) {\n          rt.safeTransfer(rewardCollector, bal);\n          emit RewardClaimed(address(rt), bal);\n        }\n      }\n    }\n  }\n}\n"
    },
    "contracts/test/MockReentrantAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../third_party/balancer/IAssetManager.sol\";\nimport \"../third_party/balancer/IBVault.sol\";\nimport \"../interfaces/IAssetManagerBase.sol\";\nimport \"./interfaces/IRelayer.sol\";\n\n\ncontract MockReentrantAssetManager is IAssetManagerBase {\n  address public underlying;\n  InvestmentConfig private _config;\n\n  constructor(\n    address,\n    address,\n    address _underlying,\n    address,\n    address\n  ){\n    underlying = _underlying;\n  }\n  function initialize(bytes32) external override {}\n\n  function setConfig(bytes32, bytes calldata) external override {}\n\n  function getInvestmentConfig(bytes32) external view override returns (InvestmentConfig memory){\n    return _config;\n  }\n\n  function getToken() external view override returns (IERC20){\n    return IERC20(underlying);\n  }\n\n\n  function getAUM(bytes32) external pure override returns (uint256){\n    return 42;\n  }\n\n  function getPoolBalances(bytes32) external pure override returns (uint256 poolCash, uint256 poolManaged){\n    return (1, 2);\n  }\n\n  function maxInvestableBalance(bytes32) external pure override returns (int256){\n    return 42;\n  }\n\n  function updateBalanceOfPool(bytes32) external override {\n\n  }\n\n  function shouldRebalance(uint256, uint256) external pure override returns (bool){\n    return true;\n  }\n\n  function rebalance(bytes32 poolId, bool) external override {\n    IAsset[] memory _assets = new IAsset[](2);\n    _assets[0] = IAsset(underlying);\n    uint256[] memory _amounts = new uint256[](2);\n    // reentrancy call\n    IBVault.JoinPoolRequest memory request = IBVault.JoinPoolRequest({\n      assets : _assets,\n      maxAmountsIn : _amounts,\n      userData : \"\",\n      fromInternalBalance : false\n    });\n    IRelayer(msg.sender).joinPool(poolId, address(0), request);\n  }\n\n  function capitalOut(bytes32, uint256) external override {}\n\n  function claimRewards() external override {}\n}\n"
    },
    "contracts/test/interfaces/IRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../../third_party/balancer/IBVault.sol\";\n\ninterface IRelayer {\n  function joinPool(bytes32 poolId, address recipient, IBVault.JoinPoolRequest memory request) external;\n}\n"
    },
    "contracts/Relayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./third_party/balancer/IBVault.sol\";\nimport \"./interfaces/IAssetManagerBase.sol\";\nimport \"./interfaces/IRelayer.sol\";\n\n/// @title Relayer\n/// @dev this contract behaves as proxy for joinPool and exitPool operations.\n///      Is able to move invested funds to the Balancer's vault and handle big exitPool requests.\n///      Need to be approved by Balancer's governance.\ncontract Relayer is IRelayer {\n  // ***************************************************\n  //                CONSTANTS\n  // ***************************************************\n\n  // We start at a non-zero value to make EIP2200 refunds lower, meaning there'll be a higher chance of them being\n  // fully effective.\n  bytes32 internal constant _EMPTY_CALLED_POOL =\n    bytes32(0x0000000000000000000000000000000000000000000000000000000000000001);\n\n  // ***************************************************\n  //                VARIABLES\n  // ***************************************************\n\n  IBVault public immutable vault;\n  bytes32 internal _calledPool;\n\n  // ***************************************************\n  //                  EVENTS\n  // ***************************************************\n\n  /// @dev all events are produced either AssetManagers or Balancer's vault.\n\n  // ***************************************************\n  //                CONSTRUCTOR\n  // ***************************************************\n\n  constructor(IBVault _vault) {\n    vault = _vault;\n    _calledPool = _EMPTY_CALLED_POOL;\n  }\n\n  // ***************************************************\n  //                    VIEWS\n  // ***************************************************\n\n  /// @dev returns true if relayer processing rebalce request for the given pool (pool Id)\n  function hasCalledPool(bytes32 poolId) external view override returns (bool) {\n    return _calledPool == poolId;\n  }\n\n  // ***************************************************\n  //                    CLAIM\n  // ***************************************************\n\n  /// @notice used to claim rewards from asset managers. Reward collection logic and\n  ///         reward distribution controlled by AM\n  function claimAssetManagerRewards(bytes32 poolId) external override {\n    (IERC20[] memory tokens, , ) = vault.getPoolTokens(poolId);\n    for (uint256 i = 0; i < tokens.length; i++) {\n      (, , , address assetManager) = vault.getPoolTokenInfo(poolId, tokens[i]);\n      if (assetManager != address(0)) {\n        IAssetManagerBase(assetManager).claimRewards();\n      }\n    }\n  }\n\n  // ***************************************************\n  //                    JOIN/EXIT\n  // ***************************************************\n\n  /// @notice a standard Balancer's vault joinPool request. Calls asset manager's rebalance logic.\n  function joinPool(\n    bytes32 poolId,\n    address recipient,\n    IBVault.JoinPoolRequest memory request\n  ) external rebalance(poolId, request.assets, new uint256[](request.assets.length)) {\n    vault.joinPool(poolId, msg.sender, recipient, request);\n  }\n\n  /// @notice standard Balancer's vault exitPool request with the extra param minCashBalances.\n  ///         minCashBalances - amounts of tokens for withdraw (exitPool). Used to calculate if AM should return tokens\n  ///                           to the Balancer's vault to handle this request.\n  ///         Calls asset manager's rebalance logic.\n  function exitPool(\n    bytes32 poolId,\n    address payable recipient,\n    IBVault.ExitPoolRequest memory request,\n    uint256[] memory minCashBalances\n  ) external rebalance(poolId, request.assets, minCashBalances) {\n    vault.exitPool(poolId, msg.sender, recipient, request);\n  }\n\n  // ***************************************************\n  //                 REBALANCE\n  // ***************************************************\n\n  /// @dev used by joinPool and exitPool to handle big exitPool and 'soft' rebalance assets (invest/devest) via AM.\n  modifier rebalance(\n    bytes32 poolId,\n    IAsset[] memory assets,\n    uint256[] memory minCashBalances\n  ) {\n    require(_calledPool == _EMPTY_CALLED_POOL, \"Rebalancing relayer reentered\");\n    IERC20[] memory tokens = _translateToIERC20(assets);\n    _ensureCashBalance(poolId, tokens, minCashBalances);\n    _calledPool = poolId;\n    _;\n    _rebalance(poolId, tokens);\n    _calledPool = _EMPTY_CALLED_POOL;\n  }\n\n  /// @dev used to handle big withdraws by devesting required funds via AM and to update Balancer's vault with the\n  ///      latest state of funds controlled by AM.\n  function _ensureCashBalance(\n    bytes32 poolId,\n    IERC20[] memory tokens,\n    uint256[] memory minCashBalances\n  ) internal {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      (uint256 cash, , , address assetManager) = vault.getPoolTokenInfo(poolId, tokens[i]);\n\n      if (assetManager != address(0)) {\n        uint256 cashNeeded = minCashBalances[i];\n        if (cash < cashNeeded) {\n          // Withdraw the managed balance back to the pool to ensure that the cash covers the withdrawal\n          // This will automatically update the vault with the most recent managed balance\n          IAssetManagerBase(assetManager).capitalOut(poolId, cashNeeded - cash);\n        } else {\n          // We want to ensure that the pool knows about all asset manager returns\n          // to avoid a new LP getting a share of returns earned before they joined.\n          // We then update the vault with the current managed balance manually.\n          IAssetManagerBase(assetManager).updateBalanceOfPool(poolId);\n        }\n      }\n    }\n  }\n\n  /// @dev calls 'soft' rebalace for attached AM.\n  function _rebalance(bytes32 poolId, IERC20[] memory tokens) internal {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      (, , , address assetManager) = vault.getPoolTokenInfo(poolId, tokens[i]);\n      if (assetManager != address(0)) {\n        // Note that malicious Asset Managers could perform reentrant calls at this stage and e.g. try to exit\n        // the Pool before Managers for other tokens have rebalanced. This is considered a non-issue as a) no\n        // exploits should be enabled by allowing for this, and b) Pools trust their Asset Managers.\n\n        // Do a non-forced rebalance\n        IAssetManagerBase(assetManager).rebalance(poolId, false);\n      }\n    }\n  }\n\n  // ***************************************************\n  //                 COMMON INTERNAL\n  // ***************************************************\n\n  function _translateToIERC20(IAsset[] memory assets) internal pure returns (IERC20[] memory) {\n    IERC20[] memory tokens = new IERC20[](assets.length);\n    for (uint256 i = 0; i < assets.length; ++i) {\n      tokens[i] = IERC20(address(assets[i]));\n    }\n    return tokens;\n  }\n}\n"
    },
    "contracts/interfaces/IRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../third_party/balancer/IBasePoolRelayer8.sol\";\n\ninterface IRelayer is IBasePoolRelayer {\n\n  function claimAssetManagerRewards(bytes32 poolId) external;\n\n}\n"
    },
    "contracts/test/MockTetuSmartVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/ISmartVault.sol\";\n\ncontract MockTetuSmartVault is ISmartVault, ERC20 {\n  using SafeERC20 for IERC20;\n\n  IERC20 public asset;\n  bool isReturnTokens;\n  bool isReturnShares;\n  uint256 underlyingDecimals;\n\n  constructor(\n    address _asset,\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    bool _isReturnShares,\n    bool _isReturnTokens\n  )ERC20(_name, _symbol, _decimals)  {\n    isReturnShares = _isReturnShares;\n    isReturnTokens = _isReturnTokens;\n    asset = IERC20(_asset);\n    underlyingDecimals = _decimals;\n  }\n\n  function underlyingBalanceInVault() external override view returns (uint256){\n    return asset.balanceOf(address(this));\n  }\n\n  function underlyingBalanceWithInvestmentForHolder(address) external override view returns (uint256){\n    return asset.balanceOf(address(this));\n  }\n\n  function deposit(uint256 amount) external override {\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    if (isReturnShares) {\n      _mint(msg.sender, amount);\n    }\n  }\n\n  function withdraw(uint256 numberOfShares) external override {\n    if (isReturnTokens) {\n      asset.transfer(msg.sender, numberOfShares);\n    }\n\n  }\n\n  function transferUnderlying(uint amount, address to) public{\n    asset.transfer(to, amount);\n  }\n\n  function underlyingUnit() external override view returns (uint256){\n    return 10**underlyingDecimals;\n  }\n\n  function getPricePerFullShare() external override view returns (uint256){\n    return 10**underlyingDecimals;\n  }\n\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals\n  ) ERC20(_name, _symbol, _decimals) {}\n\n  function mint(address to, uint256 value) external virtual {\n    _mint(to, value);\n  }\n\n  function burn(address from, uint256 value) external virtual {\n    _burn(from, value);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 150
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}